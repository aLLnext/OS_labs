# Лабораторная №4
**№1.** В программу aspace.c добавить malloc()\
и выяснить в каком направлении происходит добавление динамической памяти (к старшим адресам).\
Добавить локальную переменную и проверить то, что в стеке адреса задействуются в сторону убывания.\
Как найти адрес указателя? Что возвращается при оценивании p и &p?\
Запускаем программу и **[aspace.c](https://github.com/sapiest/OS_labs/blob/master/Lab4/aspace.c)** получаем:

```
Address of main is **0x55f249a67159**\
Address of global is **0x55f249a6a044**\
Address of local is **0x7ffcd8859928**\
Address of p is **0x55f24b7842a0**

Address of local is **0x7ffcd8859928**\
Address of new local is **0x7ffcd885992c**\
Address of p **0x55f24b7842a0**\
Address of new p is **0x55f24b784330**

Address of pointer new p is **0x7ffcd8859930**
```
Из результата видно, что новый адрес новой динамической переменной превосходит старый.\
Теперь в malloc №1 выделим 128000000, получим следующий результат:\
```
Address of main is **0x5623e28c2159**\
Address of global is **0x5623e28c5044**\
Address of local is **0x7ffcd105f768**\
Address of p is **0x7fa76b0ed010**

Address of local is **0x7ffcd105f768**\
Address of new local is **0x7ffcd105f76c**\
Address of p **0x7fa76b0ed010**\
Address of new p is **0x5623e2db62a0**

Address of pointer new p is **0x7ffcd105f770**
```
Теперь мы наблюдаем обратную ситуацию с адресами динамичеких переменных.\
(у стековых переменных адреса также увеличиваются)

Адреса также хранятся в памяти => существует адрес места памяти, в котором хранится адрес.\
Для получение адреса указателя необходимо написать **&p**.

_p_ - показывает адрес выделенной памяти с помощью **malloc**,\
_&p_ - показывает адрес выделенной **malloc** памяти.

**№2.** Объяснить поведение фрагмента кода для переменных name и name1\

```
/* Assume name shorter than 20 chars. */
  char name[20]; // заводим массив из 20 символов
  puts("Enter name: "); // выводим строку
  scanf("%19s", name); // считываем ответ, не привышая 19 символов, т. к. последний символ отводится под конец строки
  printf("Hello,  %s.\n\n\tNice to see you.\n", name); // выводим считанное имя с сообщением

  puts("Enter name: "); // выводим строку
  scanf("%19s", name); // считываем ответ, не привышая 19 символов

  // выводим считанное имя с сообщением с enter и tab
  printf("Hello,  %s.\n\n\tNice to see you.\n", name);

  char *name1 = "Anna"; // приравниваем указатель на char к началу константной строки
  char a_letter = name1[0]; // копируем первый символ

  /*получаем ошибку, так как попытались изменить константную строку, что запрещено делать, 
     * так как она хранится в области памяти доступной тольео для чтения 
     * (подробнее можно прочитать тут http://zonakoda.ru/c-stroki-v-c99.html)*/
  name1[0] = name1[3]; 
  name1[3] = a_letter; // получаем ошибку, так как попытались изменить константную строку
  puts(name1); // выводим ответ
```
**№3.** Разработать программу null. c, которая создает указатель на целое и устанавливает его в NULL\
Затем она пытается получить значение переменной по указателю (dereference).\
Объяснить результат запуска откомпилированной программы.