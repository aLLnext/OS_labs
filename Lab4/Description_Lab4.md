# Лабораторная №4
**№1.** *В программу aspace.c добавить malloc()\
и выяснить в каком направлении происходит добавление динамической памяти (к старшим адресам).\
Добавить локальную переменную и проверить то, что в стеке адреса задействуются в сторону убывания.\
Как найти адрес указателя? Что возвращается при оценивании p и &p?*\
Запускаем программу и **[aspace.c](https://github.com/sapiest/OS_labs/blob/master/Lab4/aspace.c)** получаем:

```
Address of main is **0x55f249a67159**
Address of global is **0x55f249a6a044**
Address of local is **0x7ffcd8859928**
Address of p is **0x55f24b7842a0**

Address of local is **0x7ffcd8859928**
Address of new local is **0x7ffcd885992c**
Address of p **0x55f24b7842a0**
Address of new p is **0x55f24b784330**

Address of pointer new p is **0x7ffcd8859930**
```
Из результата видно, что новый адрес новой динамической переменной превосходит старый.\
Теперь в malloc №1 выделим 128000000, получим следующий результат:
```
Address of main is **0x5623e28c2159**
Address of global is **0x5623e28c5044**
Address of local is **0x7ffcd105f768**
Address of p is **0x7fa76b0ed010**

Address of local is **0x7ffcd105f768**
Address of new local is **0x7ffcd105f76c**
Address of p **0x7fa76b0ed010**
Address of new p is **0x5623e2db62a0**

Address of pointer new p is **0x7ffcd105f770**
```
Теперь мы наблюдаем обратную ситуацию с адресами динамичеких переменных.\
(у стековых переменных адреса также увеличиваются)

Адреса также хранятся в памяти => существует адрес места памяти, в котором хранится адрес.\
Для получение адреса указателя необходимо написать **&p**.

_p_ - показывает адрес выделенной памяти с помощью **malloc**,\
_&p_ - показывает адрес выделенной **malloc** памяти.

**№2.** *Объяснить поведение фрагмента кода для переменных name и name1*
```
/* Assume name shorter than 20 chars. */
  char name[20]; // заводим массив из 20 символов
  puts("Enter name: "); // выводим строку
  scanf("%19s", name); // считываем ответ, не привышая 19 символов, т. к. последний символ отводится под конец строки
  printf("Hello,  %s.\n\n\tNice to see you.\n", name); // выводим считанное имя с сообщением

  puts("Enter name: "); // выводим строку
  scanf("%19s", name); // считываем ответ, не привышая 19 символов

  // выводим считанное имя с сообщением с enter и tab
  printf("Hello,  %s.\n\n\tNice to see you.\n", name);

  char *name1 = "Anna"; // приравниваем указатель на char к началу константной строки
  char a_letter = name1[0]; // копируем первый символ

  /*получаем ошибку, так как попытались изменить константную строку, что запрещено делать, 
     * так как она хранится в области памяти доступной тольео для чтения 
     * (подробнее можно прочитать тут http://zonakoda.ru/c-stroki-v-c99.html)*/
  name1[0] = name1[3]; 
  name1[3] = a_letter; // получаем ошибку, так как попытались изменить константную строку
  puts(name1); // выводим ответ
```
**№3.** *Разработать программу null. c, которая создает указатель на целое и устанавливает его в NULL\
Затем она пытается получить значение переменной по указателю (dereference).\
Объяснить результат запуска откомпилированной программы.*
```
  int *p = NULL;
  int i = *p;
  printf("%i", i);
```
Программа завершилась с ошибкой:\
**Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)**\
Так как мы пытались разыменовать указатель на NULL,\
В C NULL = 0, что привывело к выходу програмы за область допустимых адресов.  

**№4.** *Откомпилировать null.c с ключом -g, запустить gdb null и вызвать команду run. 
Объяснить реакцию отладчика.*
```
gcc -g null.c -o null

gdb null
(gdb) run
```

Получаем результат:
```
Program received signal SIGSEGV, Segmentation fault.
0x000055555555514d in main () at null.c:10
10        int i = *p;
```
Из чего видно, что возникла ошибка сегментации из-за попытки разыменовать NULL.

**№5.** *Установить и использовать valgrind (memcheck) для анализа ситуации из 4:\
valgrind --leak-check=yes ./null \
(valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out.txt null). 
Объяснить результат.*

Результат работы valgrind находится в файле **[valgrind-out.txt](https://github.com/sapiest/OS_labs/blob/master/Lab4/valgrind-out.txt)**\
Результат работы можно посмотреть через CLion\
Он укажет на 5 строчку программы с сообщением:\
**Address 0x0 is not stack'd, malloc'd or (recently) free'd**\
Из чего следует, что мы пытаемся разыменовать адресс NULL (т.е. 0),\
который не в области нашей программы.

**№6.** *Написать простую программу, которая использует malloc(), но не освобождает память по завершению. 
Использовать gdb и valgrind для того, чтобы объяснить ошибку.*
```
  void *p = malloc(256);
  ((int *)p)[0] = 1;
```
Запустив valgrind через CLion можно увидеть сообщение с указанием на 4 строку программы:\
**256 bytes in 1 blocks are definitely lost in loss record 1 of 1** 
Эта ошибка говорит, что мы не освободили (потеряли) 256 байт.
Она появилась из-за того, что мы не освободили память, выделенную через malloc.

**№7.** *Написать программу, которая создает массив целых data размера 100, используя malloc(). 
Установить data[100] в 0. 
Запустить программу и найти ошибку (если есть) с помощью valgrind.*
```
  int *data = malloc(sizeof(int) * 100);
  data[100] = 0;
```
По результатам выполнения программы valgrind обнаружил 2 ошибки:
1) **InvalidWrite**, выдав сообщение:\
**Address 0x522d1d0 is 0 bytes after a block of size 400 alloc'd**\
Это означает, что мы пытаемся обратиться к адресу, 
которые находится сразу сразу после выделенного с помощью malloc.\
Т.е. в нашем случае мы пытаемся обратиться к индексу 100 -> data[100], 
когда счет индексов идет с 0 и, следовательно,\
мы обращаемся к 101 элементу, на который мы не выделяли память - т.е. выход за пределы массива.
2) **Leak_DefinitelyLost**, выдав сообщение:\
**400 bytes in 1 blocks are definitely lost in loss record 1 of 1**\
Это значит, мы мы не освободили память после malloc.

**№8.** *Написать программу, которая создает массив целых (как в 7), 
освобождает его и пытается напечатать значение какого-либо элемента. 
Диагностировать ошибку с использованием valgrind.*

```
  int *data = malloc(100 * sizeof(int));
  free(data);
  printf("%i", data[1]);
```

По результатам выполнения программы valgrind обнаружил ошибку:\
**InvalidRead**, выдав сообщение:\
**Address 0x4a50044 is 4 bytes inside a block of size 400 free'd**,\
которое сообщает о том, что память к которой мы пытаеся обратиться уже освобождена.