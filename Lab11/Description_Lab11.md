# Лабораторная №11

**№1.** *vector-deadlock.c,  main-common.c и др.:
         -Выполнить  ./vector-deadlock -n 2 -l 1 -v
         которая инициирует 2 потока  (-n 2) и каждый из них осуществляет одно  сложение (-1 1) с опцией (-v).
         Объяснить результат. Меняется ли он от вызова к вызову?
         - Добавить флаг  -d и изменить количество циклов  -l .
         Всегда ли возникает состояние взаимной блокировки потоков (deadlock)?\
         - Теперь меняем число потоков -n. Есть ли такое число потоков, при котором блокировка не возникает?*

Для начала скомпилировать проект с помощью  ```make```
После вызываем программы с аргументами.

Аргументы:
```-n 2 -l 1 -v```
В функции worker нет блокировок, поэтому не определено 
из какого потока она вызовется сначала. Функция печати вызывается 
дважды для каждого из потоков. Следовательно порядок печати результатов непостоянный.

```-n 2 -l 5000 -v -d```
Увеличили число сложений. 
Взаимная блокировка возникает с увеличением числа сложений в vector_add().

```-n 20 -l 5000 -v -d```
Увеличили число потоков. 
Взаимная блокировка также может возникать.

Способ исключить взаимные блокировки в данных ситуациях - использовать 1 поток.

**№2.** *vector-global-order.c:
         - За счет чего программа избегает блокировок? 
         - Для чего предусмотрен специальный случай в vector add(), когда исходный и результирующий вектор совпадают?
         - Флаги: -t -n 2 -l 100000 -d. Как меняется время в зависимости от числа циклов и числа потоков?
         - Что происходит, когда включается ключ -p (при сложении различных векторов и одного и того же)?*
         
Программа избегает мертвых блокировок засчет упорядочивания по адресам,
благодаря этого сохраняется порядок блокировок. 
(вызываем блокировку в определенной последовательности)
Есть особый случай, когда векора совпадают , тогда нужно сделать блокировку 1 раз,
иначе произойдет взаимная блокировка.

Аргументы:
```-t -n 2 -l 100000 -d```

При увеличении числа циклов и числа потоков время возрастает.

```-t -n 2 -l 100000 -d -p```

С флагом -p время уменьшается, так как включается флаг параллеьности.

         
**№3.** *vector-try-wait.c: 
         - Нужен ли первый вызов  pthread mutex trylock()?
         - Как меняется число повторных попыток, когда растет число потоков?*
         
Первый вызов *pthread_mutex_trylock()* необходим для блокировки v_dst.
(для создания порядка блокировки)

Число повторных попыток возрастает с увеличением числа потоков.
Это объясняется тем, что переключение между потоками проиходит чаще.

         
**№4.** *vector-avoid-hold-and-wait.c: 
         - Сравнить с другими подходами.
         - Как меняется производительность в зависимости от наличия флага -p?*
         
Данный подход защищает от мертвой блокировки тем, 
что создает глобальный мьютекс для всех потоков.

Испольщование флага -p уменьшает время выполнения.

**№5.** *vector-nolock.c:
         - Сравнить семантику и производительность с другими вариантами при работе с двумя одинаковыми векторами и в случае, 
         когда каждый поток работает на своем векторе  -p.*

`````-t -n 2 -l 1000000 -d```
vector-nolock  = 4.81
vector-avoid-hold-and-wait = 2.84
vector-try-wait = 1.96
vector-global-order = 0.60

`````-t -n 2 -l 1000000 -d -p```
vector-nolock  = 0.58
vector-avoid-hold-and-wait = 0.38
vector-try-wait = 0.17
vector-global-order = 0.16

vector-nolock работает медленнее других способов.
     
  
