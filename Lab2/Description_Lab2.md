# Лабораторная №2
Управление процессами

Цель - получить представление о использовании основных APIs операционной системы. 

0. Ознакомиться с текстом и программами

Текст: Operating Systems: Three Easy Pieces (available at http://www.ostep.org)->5. Interlude: Process API

Программы: https://github.com/remzi-arpacidusseau/ostep-code/tree/master/cpu-api

Upon successful completion, fork() returns 0 to the child process and returns the process ID of the child process to the parent process. Otherwise, -1 is returned to the parent process, no child process is created, and errno is set to indicate the error.

1. В основной программе переменной x присвоить значение 100, а затем вызвать fork(). Каково значение x в порождённом процессе? Что происходит, когда основной и порожденный процесы меняют значение x?

2. Порожденный процесс, созданный с помощью fork(), должен напечатать “hello”; основной  -  “goodbye”. Нужно обеспечить, чтобы порожденный процесс печатал первым без использования wait() в основном. 

3. Сначала вызывается fork(), а затем какой-либо вариант  exec() (execl(), execle(), execlp(), execv(), execvp(),

и execvpe()) для вызова  /bin/ls. Для чего предусмотрено столько много вариантов exec()?

4. В основной программе использовать  wait() для того, чтобы дождаться завершения порожденного процесса? Что возвращает wait()? Что произойдет, если использовать wait() в порожденном процессе? Использовать waitpid() вместо of wait(). Когда использование waitpid() целесообразно?

7. Программа порождает процесс и в нем закрывает стандартный вывод (STDOUT FILENO). Что произойдет, если осуществить вызов printf() для того, чтобы что-то вывести в основном и дочернем процессах?

8. Разработать программу, которая создает два порожденных процесса и  соединет стандартный вывод одного со стандартным вводом другого с использованием pipe().